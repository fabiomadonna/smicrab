"""
Analysis API Endpoints for SMICRAB - Updated for new R service architecture
"""

import os
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Dict, Any
from pydantic import BaseModel

from app.domain.analysis.analysis_dto import (
    CreateAnalysisRequest,
    UserAnalysesResponse,
    AnalysisSchema,
    SaveAnalysisParametersRequest,
    RunAnalysisRequest,
    RunAnalysisResponse,
    AnalysisWebhookRequest,
    AnalysisWebhookResponse,
    DeleteAnalysisRequest,
    DeleteAnalysisResponse,
)
from app.Models.analysis import AnalyzeStatus
from app.domain.analysis.analysis_service import AnalysisService
from app.domain.response.response_dto import ResponseDTO
from app.infrastructure.repositories.analysis_repository import AnalysisRepository
from app.infrastructure.repositories.user_repository import UserRepository
from app.utils.api_response import APIResponse
from app.utils.db import get_db
from app.utils.auth import get_current_active_user
from app.Models.user import User

router = APIRouter()


@router.post("/create", response_model=ResponseDTO[AnalysisSchema])
async def create_analysis(
    request: CreateAnalysisRequest,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Create a new analysis."""
    try:
        # Use authenticated user
        request.user_id = current_user.user_id

        # Create analysis
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        result = await service.create_analysis(request)

        return APIResponse.send_response(
            result, message="analysis created successfully", code=201
        )

    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.get("/{analysis_id}/download/{file_type}/{file_name}")
async def download_analysis_file(
    analysis_id: str,
    file_type: str,
    file_name: str,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Download a specific file generated by the analysis."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis ownership
        await service.verify_analysis_ownership(analysis_id, str(current_user.user_id))

        # Validate file type
        valid_file_types = ["plots", "tables", "maps", "rdata"]
        if file_type not in valid_file_types:
            raise ValueError(
                f"Invalid file type. Must be one of: {', '.join(valid_file_types)}"
            )

        # Get file path
        file_path = await service.download_analysis_file(
            analysis_id, file_type, file_name
        )

        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="File not found")

        # Determine media type based on file extension
        media_type = "application/octet-stream"
        if file_name.lower().endswith((".png", ".jpg", ".jpeg")):
            media_type = f"image/{file_name.split('.')[-1].lower()}"
        elif file_name.lower().endswith(".pdf"):
            media_type = "application/pdf"
        elif file_name.lower().endswith(".csv"):
            media_type = "text/csv"
        elif file_name.lower().endswith(".rdata"):
            media_type = "application/x-r-data"

        return FileResponse(path=file_path, filename=file_name, media_type=media_type)

    except ValueError as ve:
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Legacy endpoints - maintain backward compatibility
@router.get("/{analysis_id}/status", response_model=ResponseDTO[AnalysisSchema])
async def get_analysis_status(
    analysis_id: str,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Get the status of a specific analysis (legacy endpoint)."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis ownership
        await service.verify_analysis_ownership(analysis_id, str(current_user.user_id))
        
        result = await service.get_analysis_status(analysis_id)

        return APIResponse.send_response(
            result, message="analysis status retrieved successfully", code=200
        )

    except ValueError as ve:
        raise HTTPException(status_code=404, detail=str(ve))
    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.get("/user/{user_id}", response_model=ResponseDTO[UserAnalysesResponse])
async def get_user_analyses(
    user_id: str,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Retrieve all analyses for a specific user."""
    try:
        # Ensure user can only access their own analyses
        if str(current_user.user_id) != user_id:
            raise HTTPException(
                status_code=403, 
                detail="You can only access your own analyses"
            )
        
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        result = await service.get_user_analyses(user_id)

        return APIResponse.send_response(
            result, message="user analyses retrieved successfully", code=200
        )

    except Exception as e:
        return APIResponse.send_error(message=str(e))


# Advanced endpoints for specific model operations
class ModelConfigRequest(BaseModel):
    """Request schema for model-specific configuration."""

    analysis_id: str
    model_parameters: Dict[str, Any]


@router.post("/run", response_model=ResponseDTO[RunAnalysisResponse])
async def run_analysis(
    request: RunAnalysisRequest,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Run analysis with the model type saved in the database."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis ownership
        analysis = await service.verify_analysis_ownership(request.analysis_id, str(current_user.user_id))
            
        result = await service.run_analysis(analysis)

        return APIResponse.send_response(
            result, message="analysis execution started successfully", code=200
        )

    except ValueError as ve:
        return APIResponse.send_error(message=str(ve))
    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.post("/parameters", response_model=ResponseDTO[AnalysisSchema])
async def save_analysis_parameters(
    request: SaveAnalysisParametersRequest,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Save analysis parameters to a JSON file and database."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis ownership
        await service.verify_analysis_ownership(request.analysis_id, str(current_user.user_id))
        
        result = await service.save_analysis_parameters(request)

        return APIResponse.send_response(
            result, message="analysis parameters saved successfully", code=200
        )

    except ValueError as ve:
        raise HTTPException(status_code=404, detail=str(ve))
    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.post("/webhook/completion", response_model=ResponseDTO[AnalysisWebhookResponse])
async def analysis_completion_webhook(
    request: AnalysisWebhookRequest,
    db: AsyncSession = Depends(get_db),
):
    """Webhook endpoint for R script completion notifications."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        result = await service.handle_analysis_completion_webhook(request)

        return APIResponse.send_response(
            result,
            message="analysis completion webhook processed successfully",
            code=200,
        )

    except ValueError as ve:
        raise HTTPException(status_code=404, detail=str(ve))
    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.get("/running")
async def get_running_analyses(
    db: AsyncSession = Depends(get_db),
):
    """Get information about currently running analyses."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        running_analyses = service.container_service.get_running_analyses()
        
        return APIResponse.send_response(
            {"running_analyses": running_analyses, "count": len(running_analyses)},
            message="running analyses retrieved successfully",
            code=200,
        )

    except Exception as e:
        return APIResponse.send_error(message=str(e))

@router.get("/container/{analysis_id}/status")
async def get_container_status(
    analysis_id: str,
    db: AsyncSession = Depends(get_db),
):
    """Get detailed container status for a specific analysis."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis exists
        await service.verify_analysis(analysis_id)
        
        # Get container status
        container_status = service.container_service.get_container_status(analysis_id)
        
        return APIResponse.send_response(
            container_status,
            message="container status retrieved successfully",
            code=200,
        )

    except ValueError as ve:
        raise HTTPException(status_code=404, detail=str(ve))
    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.post("/stop/{analysis_id}")
async def stop_analysis(
    analysis_id: str,
    db: AsyncSession = Depends(get_db),
):
    """Stop a running analysis container."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Stop the container
        stopped = service.container_service.stop_analysis_container(analysis_id)
        
        if stopped:
            # Update analysis status in database
            await service.update_analysis_status(analysis_id, AnalyzeStatus.error)
            await repo.add_error_message(analysis_id, "Analysis manually stopped")
            
            return APIResponse.send_response(
                {"analysis_id": analysis_id, "stopped": True},
                message="analysis stopped successfully",
                code=200,
            )
        else:
            raise HTTPException(status_code=404, detail="Analysis container not found or already stopped")

    except Exception as e:
        return APIResponse.send_error(message=str(e))


@router.delete("/{analysis_id}", response_model=ResponseDTO[DeleteAnalysisResponse])
async def delete_analysis(
    analysis_id: str,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
):
    """Delete an analysis and clean up associated resources."""
    try:
        repo = AnalysisRepository(db)
        service = AnalysisService(repo)
        
        # Verify analysis ownership
        await service.verify_analysis_ownership(analysis_id, str(current_user.user_id))
        
        request = DeleteAnalysisRequest(analysis_id=analysis_id)
        result = await service.delete_analysis(request)
        
        return APIResponse.send_response(
            result, message="analysis deleted successfully", code=200
        )
        
    except ValueError as ve:
        return APIResponse.send_error(message=str(ve), code=404)
    except Exception as e:
        return APIResponse.send_error(message=str(e))
